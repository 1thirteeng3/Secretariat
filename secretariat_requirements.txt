VISÃƒO DE PRODUTO â€“ SEGUNDO
CÃ‰REBRO SECRETARIAT
1. PropÃ³sito do Produto
O Secretariat Nasce para resolver um problema simples e profundo:â€‹
a mente humana pensa de forma contÃ­nua, multimodal e contextual, enquanto a
maioria dos apps de notas pensa em arquivos, pastas e cliques.
O propÃ³sito central Ã© criar um Segundo CÃ©rebro Operativo que:
1.â€‹ Escute o usuÃ¡rio (principalmente por voz, em qualquer lugar).â€‹
2.â€‹ Transcreva, estruture e organize automaticamente aquilo que Ã© capturado.â€‹
3.â€‹ Conecte essas informaÃ§Ãµes em uma rede viva de conceitos (tags, links, grafos).â€‹
4.â€‹ Raciocine sobre esse acervo, respondendo perguntas e propondo sÃ­nteses.â€‹
5.â€‹ Aja em nome do usuÃ¡rio: criando lembretes, agenda, notas-sÃ­ntese e conexÃµes.â€‹
6.â€‹ PermaneÃ§a privado, local e sob controle completo do usuÃ¡rio.â€‹

Em termos simples:
Transformar ideias soltas em conhecimento estruturado e acionÃ¡vel, com
o mÃ­nimo de esforÃ§o humano possÃ­vel, mantendo a mente do usuÃ¡rio no
centro do sistema â€“ e nÃ£o o contrÃ¡rio.

2. PÃºblico-Alvo
Embora o projeto seja inicialmente pessoal, a visÃ£o de produto Ã© clara sobre quem esse
sistema serve melhor:

2.1. ArquÃ©tipos de usuÃ¡rio
1.â€‹ Criadores intelectuaisâ€‹
â—‹â€‹ Escritores, ensaÃ­stas, acadÃªmicos, filÃ³sofos, pesquisadores.â€‹

â—‹â€‹ Trabalham com conceitos complexos, revisÃµes constantes, grandes volumes
de notas.â€‹
2.â€‹ Profissionais de alta complexidadeâ€‹
â—‹â€‹ Engenheiros, cientistas de dados, mÃ©dicos, advogados, estrategistas,
gestores.â€‹
â—‹â€‹ Precisam relacionar projetos, documentos, insights, decisÃµes e prazos.â€‹
3.â€‹ Neuroticamente organizados (ou querendo ser)â€‹
â—‹â€‹ UsuÃ¡rios de PKMs tradicionais (Obsidian, Logseq, Notion) que sentem:â€‹
â– â€‹ fadiga de configurar;â€‹
â– â€‹ dificuldade de manter consistÃªncia;â€‹
â– â€‹ frustraÃ§Ã£o por saber que â€œdava para ser mais inteligenteâ€.â€‹
4.â€‹ Pessoas em fluxo constanteâ€‹
â—‹â€‹ Quem tem ideias fora da mesa de trabalho:â€‹
â– â€‹ na rua, no transporte, treinando, cozinhando.â€‹
â—‹â€‹ Dependem do celular para capturar, mas querem o desktop como cÃ©rebro
central.â€‹

2.2. Necessidades centrais
Esse pÃºblico precisa de:
â—â€‹ Captura com atrito mÃ­nimo (voz > teclado quando estÃ¡ em movimento).â€‹
â—â€‹ OrganizaÃ§Ã£o automÃ¡tica assistida, nÃ£o manual o tempo todo.â€‹
â—â€‹ MemÃ³ria confiÃ¡vel, com capacidade de â€œencontrar coisas que eu nem lembrava
que existiamâ€.â€‹
â—â€‹ ConexÃµes inteligentes, transformando notas isoladas em um sistema de ideias.â€‹
â—â€‹ Agente que faÃ§a coisas, nÃ£o sÃ³ que armazene: lembretes, resumos, sÃ­nteses,
links.â€‹

3. Contexto e Problema
3.1. O cenÃ¡rio atual
Ferramentas como Obsidian, Logseq, Notion e afins:
â—â€‹ Excelentes como repositÃ³rio de notas e grafos;â€‹
â—â€‹ Poderosas em customizaÃ§Ã£o (plugins, templates, scripts);â€‹
â—â€‹ Mas dependem demais do usuÃ¡rio para:â€‹
â—‹â€‹ criar estrutura,â€‹
â—‹â€‹ manter padrÃµes,â€‹
â—‹â€‹ lembrar de revisar,â€‹
â—‹â€‹ relacionar ideias,â€‹
â—‹â€‹ tomar aÃ§Ãµes com base no que estÃ¡ registrado.â€‹

Na prÃ¡tica, o que acontece:
â—â€‹ O usuÃ¡rio acumula dezenas/centenas/milhares de notas.â€‹
â—â€‹ O grafo cresce, mas a navegaÃ§Ã£o vira arqueologia manual.â€‹
â—â€‹ A captura por voz Ã© rara, frÃ¡gil ou feita por apps externos.â€‹
â—â€‹ AutomaÃ§Ã£o existe, mas espalhada, fragmentada, plugin-dependent.â€‹

3.2. A lacuna
NÃ£o existe, de forma integrada e local-first, um sistema que:
â—â€‹ una PKM profundo (grafo, notas, texto longo),â€‹
â—â€‹ com captura multimodal fluida (principalmente voz),â€‹
â—â€‹ com IA nativamente embutida como agente, nÃ£o como â€œplugin de luxoâ€.â€‹

HÃ¡ ferramentas que:

â—â€‹ armazenam,â€‹
â—â€‹ mostram,â€‹
â—â€‹ estendem.â€‹

Mas poucas que:
escutam â†’ entendem â†’ organizam â†’ conectam â†’ lembram â†’ agem, em
um mesmo fluxo.

4. Promessa de Valor
A promessa do Secretariatpode ser formulada em trÃªs planos:

4.1. Funcional
Capture qualquer ideia, em qualquer lugar, e o sistema transforma isso em
notas organizadas, conectadas e utilizÃ¡veis â€“ sem vocÃª precisar cuidar de
tudo manualmente.
â—â€‹ Captura por voz no celular â†’ nota estruturada e indexada no desktop.â€‹
â—â€‹ OrganizaÃ§Ã£o automÃ¡tica de tags, links e resumos.â€‹
â—â€‹ Chat com o acervo para responder perguntas especÃ­ficas.â€‹
â—â€‹ Agenda e alarmes integrados Ã s notas.â€‹

4.2. Cognitivo
Reduzir a carga mental de â€œlembrar de lembrarâ€.
â—â€‹ O sistema lembra por vocÃª o que jÃ¡ pensou/escreveu.â€‹
â—â€‹ Mostra conexÃµes que vocÃª nÃ£o tinha explicitado.â€‹
â—â€‹ Sugere sÃ­nteses e notas-mÃ£e para temas recorrentes.â€‹
â—â€‹ Ajuda a revisar ideias em momentos relevantes (via eventos e alarmes).â€‹

4.3. FilosÃ³fico / existencial

Ajudar a construir uma mente externa, coautor do seu pensamento.
â—â€‹ Em vez de â€œeu tenho um app de notasâ€, a sensaÃ§Ã£o Ã©:â€‹
â—‹â€‹ â€œeu converso com uma extensÃ£o confiÃ¡vel da minha prÃ³pria menteâ€.â€‹
â—â€‹ O produto toma forma de organismo simbÃ³lico:â€‹
â—‹â€‹ cresce com vocÃª,â€‹
â—‹â€‹ reflete sua histÃ³ria,â€‹
â—‹â€‹ participa da sua tomada de decisÃ£o.â€‹

5. Diferenciais de Produto (em si)
Antes de comparar com Obsidian, vamos descrever os pilares internos:

5.1. Local-first, com arquitetura hub-satÃ©lite
â—â€‹ Hub (Desktop):â€‹
â—‹â€‹ guarda tudo: notas, metadados, embeddings, grafo, agenda.â€‹
â—‹â€‹ oferece UI completa de navegaÃ§Ã£o, ediÃ§Ã£o, visualizaÃ§Ã£o.â€‹
â—‹â€‹ expÃµe API local para o mobile.â€‹
â—â€‹ SatÃ©lite (Mobile):â€‹
â—‹â€‹ focado em voz, agenda rÃ¡pida e chat.â€‹
â—‹â€‹ age como â€œmicrofone e terminalâ€ do cÃ©rebro central.â€‹

5.2. IA nÃ£o Ã© um plugin â€“ Ã© parte da espinha dorsal
â—â€‹ IA nÃ£o entra como â€œopÃ§Ã£o no menu extrasâ€.â€‹
â—â€‹ Ela estÃ¡ no fluxo principal:â€‹
â—‹â€‹ ao criar uma nota por voz;â€‹

â—‹â€‹ ao salvar uma nota manual, sugerindo tags;â€‹
â—‹â€‹ ao perguntar algo ao sistema;â€‹
â—‹â€‹ ao criar um lembrete a partir de uma nota.â€‹

5.3. ConversaÃ§Ã£o como interface primÃ¡ria
â—â€‹ VocÃª nÃ£o apenas consulta.â€‹
â—â€‹ VocÃª dialoga com o acervo:â€‹
â—‹â€‹ â€œO que jÃ¡ escrevi sobre X?â€â€‹
â—‹â€‹ â€œResuma tudo que tenho sobre Y e proponha prÃ³ximos passos.â€â€‹
â—‹â€‹ â€œCrie uma nota mÃ£e sobre este tema com base nestas notas.â€â€‹

5.4. IntegraÃ§Ã£o orgÃ¢nica entre notas, agenda e aÃ§Ã£o
â—â€‹ Notas podem virar eventos.â€‹
â—â€‹ Eventos sÃ£o ancorados em notas.â€‹
â—â€‹ Lembretes nascem de conversas:â€‹
â—‹â€‹ â€œDaqui a duas semanas, me lembre de revisar esta sÃ­ntese.â€â€‹

6. Escopo do V0/V1 â€“ O que entra na primeira
versÃ£o â€œusÃ¡velâ€
6.1. NÃºcleo funcional do V0/V1
No Desktop (hub):
1.â€‹ GestÃ£o de notasâ€‹
â—‹â€‹ Criar, editar, deletar notas em Markdown com frontmatter.â€‹
â—‹â€‹ Campos bÃ¡sicos:â€‹

â– â€‹ id, title, created_at, updated_at, tags, links, ai_summary.â€‹
â—‹â€‹ Lista de notas, filtro por tags, busca textual.â€‹
2.â€‹ Tags e linksâ€‹
â—‹â€‹ Tags bÃ¡sicas (criadas manualmente ou aceitando sugestÃµes).â€‹
â—‹â€‹ Links do tipo [[nome da nota]].â€‹
â—‹â€‹ VisualizaÃ§Ã£o simples de conexÃµes (mesmo que o grafo completo venha
depois).â€‹
3.â€‹ IA aplicada Ã s notasâ€‹
â—‹â€‹ Refinar/estruturar nota (melhorar organizaÃ§Ã£o textual).â€‹
â—‹â€‹ Gerar resumo da nota.â€‹
â—‹â€‹ Sugerir tags.â€‹
4.â€‹ Chat com o acervoâ€‹
â—‹â€‹ Caixa de chat no desktop:â€‹
â– â€‹ pergunta â†’ busca notas relevantes â†’ resposta baseada nas notas.â€‹
â—‹â€‹ Indicar quais notas foram usadas.â€‹
5.â€‹ Agenda bÃ¡sicaâ€‹
â—‹â€‹ Criar eventos manualmente (tÃ­tulo, data/hora).â€‹
â—‹â€‹ Vincular evento a uma nota.â€‹
â—‹â€‹ Listar prÃ³ximos eventos.â€‹
â—‹â€‹ Alarmes simples no desktop (notificaÃ§Ã£o bÃ¡sica).â€‹

No Mobile (satÃ©lite):
6.â€‹ Captura de nota por vozâ€‹
â—‹â€‹ BotÃ£o â€œNova nota por vozâ€.â€‹
â—‹â€‹ Grava Ã¡udio â†’ transcreve â†’ envia ao desktop.â€‹

â—‹â€‹ Desktop:â€‹
â– â€‹ usa IA para estruturar nota,â€‹
â– â€‹ gera tags sugeridas,â€‹
â– â€‹ armazena e indexa.â€‹
â—‹â€‹ Mobile:â€‹
â– â€‹ exibe feedback: â€œNota criadaâ€.â€‹
7.â€‹ CriaÃ§Ã£o de lembrete por vozâ€‹
â—‹â€‹ BotÃ£o â€œNovo lembrete por vozâ€.â€‹
â—‹â€‹ â€œCria um lembrete amanhÃ£ Ã s 9h pra revisar o texto talâ€¦â€â€‹
â—‹â€‹ Desktop:â€‹
â– â€‹ interpreta intenÃ§Ã£o via IA,â€‹
â– â€‹ cria evento na agenda.â€‹
â—‹â€‹ Mobile:â€‹
â– â€‹ exibe confirmaÃ§Ã£o.â€‹
8.â€‹ Chat com IA pelo mobileâ€‹
â—‹â€‹ Chat simples:â€‹
â– â€‹ texto ou voz â†’ transcriÃ§Ã£o â†’ envio ao desktop â†’ resposta.â€‹
â—‹â€‹ Speech-to-text no mobile, text-to-speech opcional.â€‹
9.â€‹ VisualizaÃ§Ã£o bÃ¡sica da agenda no mobileâ€‹
â—‹â€‹ Lista dos prÃ³ximos eventos provenientes do desktop.â€‹

6.2. O que fica fora do V0 (para nÃ£o sabotar o foco)
â—â€‹ ImportaÃ§Ã£o de fontes externas (PDF, web, e-mail).â€‹
â—â€‹ Sistemas avanÃ§ados de spaced repetition.â€‹

â—â€‹ Suporte a mÃºltiplos hubs (vÃ¡rios desktops sincronizados).â€‹
â—â€‹ VisualizaÃ§Ã£o de grafo avanÃ§ada com clustering sofisticado.â€‹
â—â€‹ Plugins de terceiros.â€‹
â—â€‹ Modelos de IA locais integrados (pensados para versÃµes posteriores).â€‹

7. O que esse app faz que um Obsidian + plugins
nÃ£o faz (ou nÃ£o faz de forma nativa, integrada e
simples)
Aqui vem o ponto-chave que diferencia tua proposta de apenas â€œmais um Obsidian com IAâ€.

7.1. Voz como primeira classe, e nÃ£o workaround
â—â€‹ Em Obsidian + plugins:â€‹
â—‹â€‹ Captura de voz Ã© gambiarra:â€‹
â– â€‹ app externo de gravaÃ§Ã£o,â€‹
â– â€‹ plugin de transcriÃ§Ã£o,â€‹
â– â€‹ workflow manual.â€‹
â—‹â€‹ NÃ£o hÃ¡ um fluxo nativo â€œfale â†’ virou nota estruturadaâ€.â€‹
â—â€‹ No Secretariat:â€‹
â—‹â€‹ O design central prevÃª:â€‹
â– â€‹ app mobile minimalista dedicado a voz;â€‹
â– â€‹ um pipeline explÃ­cito: voz â†’ transcriÃ§Ã£o â†’ IA â†’ nota estruturada â†’
tags â†’ links.â€‹
â—‹â€‹ A voz Ã© o input principal para captura rÃ¡pida, nÃ£o um extra.â€‹

7.2. IA como agente de operaÃ§Ã£o, nÃ£o apenas â€œassistente textualâ€

â—â€‹ Em Obsidian + plugins:â€‹
â—‹â€‹ IA costuma ser usada como:â€‹
â– â€‹ resumos pontuais,â€‹
â– â€‹ geraÃ§Ã£o de texto,â€‹
â– â€‹ comandos limitados por prompt.â€‹
â—‹â€‹ O usuÃ¡rio ainda precisa:â€‹
â– â€‹ lembrar de chamar IA,â€‹
â– â€‹ decidir quando,â€‹
â– â€‹ encaixar manualmente os resultados no sistema.â€‹
â—â€‹ No Secretariat:â€‹
â—‹â€‹ IA estÃ¡ embutida no fluxo cotidiano:â€‹
â– â€‹ criaÃ§Ã£o de notas (principalmente via voz),â€‹
â– â€‹ organizaÃ§Ã£o (tags, links, resumos),â€‹
â– â€‹ aÃ§Ãµes (criar eventos, notas-sÃ­ntese, lembretes).â€‹
â—‹â€‹ IA:â€‹
â– â€‹ age sobre o sistema,â€‹
â– â€‹ nÃ£o sÃ³ responde em um painel lateral.â€‹

7.3. Arquitetura hub-satÃ©lite desenhada desde o inÃ­cio
â—â€‹ Obsidian Ã© essencialmente um editor/visualizador de arquivos, com sync opcional e
parcialmente acoplado.â€‹
â—â€‹ O Secretariat:â€‹
â—‹â€‹ nasce com a ideia de:â€‹
â– â€‹ Desktop = cÃ©rebro (storage, index, agenda, IA, grafo).â€‹

â– â€‹ Mobile = Ã³rgÃ£o sensorial e de comando, com foco em voz e
consulta leve.â€‹
â—‹â€‹ Fluxos de rede sÃ£o parte do modelo mental do produto, nÃ£o um extra.â€‹

7.4. IntegraÃ§Ã£o orgÃ¢nica entre notas, IA e agenda
â—â€‹ Em Obsidian:â€‹
â—‹â€‹ Existe calendÃ¡rio, tasks, etc., mas tudo depende de plugins e disciplina
manual.â€‹
â—‹â€‹ NÃ£o hÃ¡ um vÃ­nculo nativo: â€œessa nota gera um eventoâ€, mediado por IA.â€‹
â—â€‹ No Secretariat:â€‹
â—‹â€‹ A relaÃ§Ã£o nota â†” evento Ã© natural:â€‹
â– â€‹ â€œCrie um evento para revisar esta nota em duas semanas.â€â€‹
â– â€‹ â€œListe as notas associadas aos eventos desta semana.â€â€‹
â—‹â€‹ A agenda nÃ£o Ã© um plugin: Ã© uma camada temporal do teu conhecimento,
que a IA manipula.â€‹

7.5. ConversaÃ§Ã£o com o acervo como interface padrÃ£o, nÃ£o funÃ§Ã£o
opcional
â—â€‹ Em Obsidian:â€‹
â—‹â€‹ Plugins de IA podem responder usando um subconjunto de notas, mas nÃ£o Ã©
o fluxo central.â€‹
â—â€‹ No Secretariat:â€‹
â—‹â€‹ â€œPerguntar ao cÃ©rebroâ€ Ã© uma forma primÃ¡ria de navegaÃ§Ã£o.â€‹
â—‹â€‹ A UI favorece:â€‹
â– â€‹ perguntar,â€‹
â– â€‹ explorar,â€‹
â– â€‹ pedir sÃ­ntese,â€‹

â– â€‹ pedir relaÃ§Ãµes,â€‹
â– â€‹ mandar â€œfaÃ§aâ€ (crie nota, crie lembrete, conecte temas).â€‹

7.6. Foco extremo na experiÃªncia de uso single-user local-first
â—â€‹ Obsidian Ã©, por natureza, um app altamente generalista e (cada vez mais) uma
plataforma.â€‹
â—â€‹ SecretariatÃ©:â€‹
â—‹â€‹ radicalmente orientado a um Ãºnico cÃ©rebro humano;â€‹
â—‹â€‹ desenhado para funcionar bem sozinho, sem time/colaboraÃ§Ã£o.â€‹
â—‹â€‹ NÃ£o quer ser a ferramenta de todos; quer ser a extensÃ£o de uma cabeÃ§a.â€‹

8. PrincÃ­pios orientadores do produto
Para guiar futuras decisÃµes (de UX, arquitetura, features), alguns princÃ­pios:
1.â€‹ FricÃ§Ã£o mÃ­nima na capturaâ€‹
â—‹â€‹ Quanto menos cliques entre â€œideiaâ€ e â€œnotaâ€, melhor.â€‹
â—‹â€‹ Voz + IA devem reduzir essa distÃ¢ncia ao mÃ­nimo.â€‹
2.â€‹ AutomaÃ§Ã£o sem opacidadeâ€‹
â—‹â€‹ A IA organiza e age, mas sempre de forma:â€‹
â– â€‹ auditÃ¡vel,â€‹
â– â€‹ reversÃ­vel,â€‹
â– â€‹ transparente.â€‹
3.â€‹ Local-first e user-ownedâ€‹
â—‹â€‹ Dados no dispositivo.â€‹
â—‹â€‹ Arquivos legÃ­veis.â€‹

â—‹â€‹ Sem dependÃªncia de nuvem obrigatÃ³ria.â€‹
4.â€‹ ConvergÃªncia entre memÃ³ria, raciocÃ­nio e aÃ§Ã£oâ€‹
â—‹â€‹ Notas nÃ£o sÃ£o sÃ³ â€œtexto paradoâ€.â€‹
â—‹â€‹ Elas alimentam agentes (IA + agenda) que geram movimento.â€‹
5.â€‹ Escalabilidade cognitiva, nÃ£o corporativaâ€‹
â—‹â€‹ O objetivo nÃ£o Ã© escalar para 1 bilhÃ£o de usuÃ¡rios,â€‹
â—‹â€‹ e sim ser profundamente bom para um nÃºmero menor de pessoas que
querem um segundo cÃ©rebro sÃ©rio.â€‹

Se vocÃª quiser, no prÃ³ximo passo posso derivar deste documento:
â—â€‹ um resumo executivo de 1 pÃ¡gina;â€‹
â—â€‹ um canvas de escopo do V0/V1 (lista de features â€œentra / nÃ£o entraâ€);â€‹
â—â€‹ ou uma matriz comparativa direta (tabela) entre Secretariat x Obsidian+plugins x
Logseq, focada em visÃ£o de produto.â€‹

Abaixo apresento a DocumentaÃ§Ã£o de Arquitetura TÃ©cnica do Secretariat v1.0. Este
documento serve como a "ConstituiÃ§Ã£o" do cÃ³digo, definindo as tecnologias, os padrÃµes de
comunicaÃ§Ã£o e a estrutura modular para garantir que o projeto seja escalÃ¡vel, performÃ¡tico
e fiel Ã  visÃ£o de "Segundo CÃ©rebro Ativo".

1. VisÃ£o Geral da Arquitetura (High-Level
Architecture)
O Secretariat adota uma arquitetura distribuÃ­da e assimÃ©trica, conhecida como "Hub and
Satellite".
â—â€‹ O Hub (Desktop): Onde reside a inteligÃªncia, o banco de dados vetorial, o
processamento pesado e a "Verdade" dos dados (Arquivos Markdown).
â—â€‹ O SatÃ©lite (Mobile): Um terminal leve focado em captura (Input) e consulta rÃ¡pida
(Agenda), operando sob o princÃ­pio Offline-First.
â—â€‹ O Relay (Nuvem/IntermediÃ¡rio): Um buffer de sincronizaÃ§Ã£o burro (dumb pipe). Ele
nÃ£o processa dados, apenas armazena filas de mensagens criptografadas atÃ© que o
Hub as consuma.

Diagrama de Fluxo de Dados
Snippet de cÃ³digo
graph TD
UserMobile((UsuÃ¡rio Mobile)) -->|Voz/Texto| MobileApp[App React Native]
MobileApp -->|Armazena| LocalDB_Mob[(WatermelonDB)]
MobileApp -->|Sync/Upload| Relay[Supabase / Relay DB]

Relay -->|Polling/Websocket| DesktopApp[Desktop App (Tauri)]

subgraph "Desktop Environment (The Hub)"
DesktopApp -->|Orquestra| RustCore[Rust Backend]
RustCore -->|LÃª/Escreve| FileSystem[Markdown Vault]
RustCore -->|Indexa| SQLite[(SQLite + Vector Ext)]
RustCore -->|Envia Ãudio/Texto| AI_API[LLM & Whisper API]
AI_API -->|Retorna JSON| RustCore
end

2. Stack TecnolÃ³gica (As Escolhas de
Engenharia)
A escolha foca na hibridizaÃ§Ã£o: Rust para o que exige CPU/IO bruto, TypeScript para a
flexibilidade de UI e compartilhamento de lÃ³gica.

2.1. Desktop (The Hub)
â—â€‹ Runtime: Tauri v2.
â—‹â€‹ Por que: Permite usar o frontend web moderno, mas compila um binÃ¡rio
minÃºsculo e seguro. O backend Ã© Rust nativo, permitindo acesso direto ao
SO sem o overhead do Node.js/Electron.
â—â€‹ Linguagem de Backend: Rust.

â—‹â€‹ Bibliotecas Chave: Tokio (Async runtime), Serde (SerializaÃ§Ã£o rÃ¡pida), SQLx
(Banco de dados), Tantivy (Search engine full-text em Rust) ou Qdrant
(Vector search).
â—â€‹ Frontend: React + Vite.
â—‹â€‹ Styling: TailwindCSS + Shadcn/UI (para velocidade de dev).
â—‹â€‹ Gerenciamento de Estado: Zustand (leve) + TanStack Query (para sync).
â—‹â€‹ VisualizaÃ§Ã£o de Grafos: react-force-graph-3d (renderizado via WebGL).

2.2. Mobile (The Satellite)
â—â€‹ Framework: React Native (via Expo).
â—‹â€‹ Por que: Permite compartilhar interfaces (Typescript) e lÃ³gica de validaÃ§Ã£o
com o Desktop (Monorepo).
â—â€‹ Banco Local: WatermelonDB (baseado em SQLite, otimizado para sync em React
Native).

2.3. Infraestrutura & Sync (The Relay)
â—â€‹ ServiÃ§o: Supabase (PostgreSQL).
â—‹â€‹ Uso: Tabelas para filas de mensagens (inbox_queue) e armazenamento de
blobs (Ã¡udio).
â—‹â€‹ AutenticaÃ§Ã£o: Supabase Auth (garante que sÃ³ o dono acesse seus dados).

3. Arquitetura de Baixo NÃ­vel (Low-Level
Architecture)
Aqui detalhamos como os mÃ³dulos Rust e TS conversam.

3.1. Design HÃ­brido: Onde roda o quÃª?
Funcionalidade

Camada
(Linguagem)

Justificativa

Interface de
UsuÃ¡rio

TypeScript
(React)

IteraÃ§Ã£o rÃ¡pida, ecossistema rico de UI.

Parsing de
Markdown

Rust

Precisa ler milhares de arquivos em
milissegundos para gerar o grafo.

CÃ¡lculo do Grafo

Rust

Algoritmos de forÃ§a (force-directed) sÃ£o
CPU-intensive. Rust calcula as posiÃ§Ãµes
X,Y,Z e envia para a UI apenas
renderizar.

ComunicaÃ§Ã£o API
(IA)

Rust

Gerenciamento seguro de chaves de API
e streaming de resposta mais estÃ¡vel.

Watcher de
Arquivos

Rust

Monitorar mudanÃ§as no File System
requer acesso baixo nÃ­vel ao SO.

Ãudio Recorder

TypeScript (Web
API)

APIs de navegador/mobile sÃ£o suficientes
e mais fÃ¡ceis de manusear para UX.

3.2. Estrutura de MÃ³dulos Rust (Crates)
O backend do Tauri serÃ¡ dividido em mÃ³dulos para manter a sanidade do cÃ³digo
(src-tauri/src/):
1.â€‹ mod ai_orchestrator:
â—‹â€‹ ResponsÃ¡vel por montar o payload para a LLM.
â—‹â€‹ ContÃ©m os System Prompts versionados.
â—‹â€‹ Recebe o JSON da IA, valida o Schema e devolve erro ou sucesso.
2.â€‹ mod vault_manager:
â—‹â€‹ AbstraÃ§Ã£o do sistema de arquivos.
â—‹â€‹ FunÃ§Ãµes: Notes(), update_frontmatter(), append_to_daily_note().
â—‹â€‹ Garante atomicidade: nunca corromper um arquivo .md se o app fechar.
3.â€‹ mod graph_engine:
â—‹â€‹ LÃª todos os .md, extrai links [[]].
â—‹â€‹ ConstrÃ³i a matriz de adjacÃªncia na memÃ³ria.
â—‹â€‹ Calcula mÃ©tricas de centralidade (quais notas sÃ£o mais importantes).
4.â€‹ mod sync_service:
â—‹â€‹ ServiÃ§o em background (thread separada) que faz polling no Supabase.
â—‹â€‹ Baixa Ã¡udios pendentes, processa e marca como processed.

3.3. Schema de Dados (Protocolo de ComunicaÃ§Ã£o)
Para garantir que a IA estruture corretamente, definimos interfaces estritas.
Interface da Nota (JSON IntermediÃ¡rio)
TypeScript

interface ProcessedInput {
original_transcription: string;
intent: 'NOTE' | 'TASK' | 'EVENT' | 'JOURNAL';
suggested_content: {
title: string;
body_markdown: string; // ConteÃºdo formatado
tags: string[]; // ex: ["#projeto-x", "#ideia"]
linked_notes: string[]; // ex: ["[[ReuniÃ£o Anterior]]"]
};
metadata: {
created_at: string;
source_device: string;
confidence_score: number;
};
schedule?: { // Apenas se intent for TASK ou EVENT
start_time: string; // ISO 8601
end_time?: string;
recurrence?: string;
};
}

4. Estrutura de Pastas e RepositÃ³rios
(Monorepo)
Utilizaremos um Monorepo gerenciado por pnpm workspaces ou Turborepo. Isso permite
que o cÃ³digo TypeScript de "Tipos" e "Utilidades" seja importado tanto pelo Mobile quanto
pelo Desktop.
Nome do RepositÃ³rio: secretariat-monorepo

Plaintext
/secretariat-monorepo
â”‚
â”œâ”€â”€ /apps
â”‚ â”œâ”€â”€ /desktop (Tauri App)
â”‚ â”‚ â”œâ”€â”€ /src-tauri

# O CoraÃ§Ã£o em Rust

â”‚ â”‚ â”‚ â”œâ”€â”€ /src
â”‚ â”‚ â”‚ â”‚ â”œâ”€â”€ main.rs

# Entry point

â”‚ â”‚ â”‚ â”‚ â”œâ”€â”€ ai.rs

# MÃ³dulo de IA

â”‚ â”‚ â”‚ â”‚ â”œâ”€â”€ vault.rs

# ManipulaÃ§Ã£o de Markdown

â”‚ â”‚ â”‚ â”‚ â””â”€â”€ graph.rs

# Algoritmos de Grafo

â”‚ â”‚ â”‚ â”œâ”€â”€ Cargo.toml
â”‚ â”‚ â”‚ â””â”€â”€ tauri.conf.json
â”‚ â”‚ â”‚
â”‚ â”‚ â””â”€â”€ /src

# UI Desktop (React)

â”‚ â”‚

â”œâ”€â”€ /components

â”‚ â”‚

â”œâ”€â”€ /stores

â”‚ â”‚

â””â”€â”€ App.tsx

# Zustand (Estado global)

â”‚ â”‚
â”‚ â””â”€â”€ /mobile (Expo / React Native)
â”‚

â”œâ”€â”€ /app

# Rotas (Expo Router)

â”‚

â”œâ”€â”€ /services

# LÃ³gica de gravaÃ§Ã£o/sync

â”‚

â””â”€â”€ app.json

â”‚
â”œâ”€â”€ /packages
â”‚ â”œâ”€â”€ /shared-types

# Interfaces TS (Note, Task, Event)

â”‚ â”‚ â””â”€â”€ index.ts

# O "Contrato" entre IA, Mobile e Desktop

â”‚ â”‚
â”‚ â””â”€â”€ /shared-utils

# Validadores, formatadores de data

â”‚
â”œâ”€â”€ /infra

# Docker compose para Supabase local (dev)

â”œâ”€â”€ package.json
â””â”€â”€ README.md

Raiz (package.json)
{
"name": "secretariat-monorepo",
"version": "0.0.1",
"private": true,
"scripts": {
"dev:desktop": "pnpm --filter desktop tauri dev",
"dev:mobile": "pnpm --filter mobile start",
"build": "pnpm --filter desktop tauri build",
"type-check": "pnpm -r exec tsc --noEmit"
},
"devDependencies": {
"turbo": "^1.10.0",
"typescript": "^5.0.0"

},
"workspaces": [
"apps/*",
"packages/*"
]
}

Rust Dependencies (Cargo.toml)
// Prevents additional console window on Windows in release, DO NOT
REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use std::sync::Mutex;
use tauri::State;

// Definindo estruturas bÃ¡sicas para o estado do app
struct AppState {
// Exemplo: ConexÃ£o com banco de dados local ou status do sync
db_connection: Mutex<Option<String>>,
}

// --- MÃ“DULO 1: COMANDOS DO SISTEMA DE ARQUIVOS (VAULT) ---

#[tauri::command]
fn create_note(title: String, content: String, tags: Vec<String>) ->
Result<String, String> {
// TODO: Implementar lÃ³gica real de salvamento em .md
// 1. Sanitizar tÃ­tulo
// 2. Criar Frontmatter com as tags
// 3. Escrever no disco
println!("Criando nota: {} com tags {:?}", title, tags);
Ok(format!("Nota '{}' criada com sucesso.", title))
}

// --- MÃ“DULO 2: ORQUESTRADOR DE IA ---

#[derive(serde::Serialize, serde::Deserialize)]
struct AIRequest {
input_text: String,
context_notes: Vec<String>, // IDs ou TÃ­tulos de notas para
contexto
}

#[derive(serde::Serialize, serde::Deserialize)]
struct AIParsedResponse {
title: String,
markdown_content: String,
tags: Vec<String>,
suggested_links: Vec<String>
}

#[tauri::command]
async fn process_input_with_ai(input: String) ->
Result<AIParsedResponse, String> {
// TODO: Implementar chamada HTTP para OpenAI/Groq via biblioteca
'reqwest'
// Esta funÃ§Ã£o deve ser async para nÃ£o travar a UI

// Mock de retorno para teste de UI
Ok(AIParsedResponse {
title: "Mock Note from AI".into(),
markdown_content: format!("# Resumo\n\nBaseado no input:
'{}'...", input),
tags: vec!["#mock".into(), "#teste".into()],
suggested_links: vec!["[[Nota Relacionada]]".into()]

})
}

// --- MÃ“DULO 3: SYNC ENGINE --// Este comando seria chamado periodicamente pelo Frontend ou rodaria
em thread separada
#[tauri::command]
async fn trigger_sync() -> Result<String, String> {
println!("Iniciando sincronizaÃ§Ã£o com Supabase...");
// 1. Check internet
// 2. Fetch from 'inbox' table
// 3. Download audio/text blobs
Ok("Sync finalizado".into())
}

fn main() {
tauri::Builder::default()
.manage(AppState { db_connection: Mutex::new(None) })
.invoke_handler(tauri::generate_handler![
create_note,
process_input_with_ai,

trigger_sync
])
.run(tauri::generate_context!())
.expect("error while running tauri application");
}

Esqueleto do Backend Rust (main.rs)
[package]
name = "secretariat-desktop"
version = "0.0.1"
description = "The Core Brain of Secretariat"
authors = ["You"]
edition = "2021"

[build-dependencies]
tauri-build = { version = "2.0.0-beta", features = [] }

[dependencies]
tauri = { version = "2.0.0-beta", features = ["fs", "shell", "dialog", "http-request"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

tokio = { version = "1", features = ["full"] } # Runtime Async para Rust
reqwest = { version = "0.11", features = ["json"] } # Client HTTP para API de IA
chrono = { version = "0.4", features = ["serde"] } # ManipulaÃ§Ã£o de Data/Hora
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "sqlite"] } # Banco de dados Local
uuid = { version = "1.4", features = ["v4", "serde"] }

# Para o Grafo (Graph Analysis) - Opcional nesta fase
petgraph = "0.6"

[features]
# this feature is used for production builds or when `devPath` points to the filesystem
custom-protocol = ["tauri/custom-protocol"]

O contrato de dados compartilhado (types.ts)â€‹

// Este arquivo define a linguagem comum entre o App Mobile, a IA e o
Desktop.

/**
* Representa a intenÃ§Ã£o detectada pela IA no input do usuÃ¡rio
*/
export type IntentType = 'QUICK_NOTE' | 'TASK' | 'CALENDAR_EVENT' |
'JOURNAL_ENTRY';

/**
* Estrutura de dados que trafega do Mobile para o Desktop (via
Relay/Supabase)
*/
export interface InboxItem {
id: string; // UUID
source_device_id: string;
created_at: string; // ISO String
content_type: 'AUDIO' | 'TEXT';
content_url?: string; // URL do Ã¡udio no Storage bucket (se audio)
raw_text?: string;

// O texto digitado (se texto)

status: 'PENDING' | 'PROCESSING' | 'WAITING_APPROVAL' | 'DONE';
}

/**
* O formato que a IA deve devolver (Structured Output)
*/
export interface AIStructuredResult {
title: string;
summary: string;
formatted_markdown: string;
detected_intent: IntentType;

// Metadata gerado pela IA
tags: string[];

suggested_backlinks: string[]; // TÃ­tulos de outras notas

// Se for uma tarefa ou evento
action_item?: {
due_date?: string;
priority: 'HIGH' | 'MEDIUM' | 'LOW';
is_event: boolean; // Se true, vai pra agenda
}
}

/**
* Estrutura de um NÃ³ no Grafo de Conhecimento
*/
export interface GraphNode {
id: string; // Caminho do arquivo ou UUID
name: string; // TÃ­tulo da nota
val: number; // Peso (baseado no nÃºmero de conexÃµes)
group?: string; // Baseado em Tags principais
}

export interface GraphLink {
source: string; // ID do nÃ³ origem
target: string; // ID do nÃ³ destino
}

export interface GraphData {
nodes: GraphNode[];
links: GraphLink[];
}

5. Plano Mestre de ImplementaÃ§Ã£o do
Secretariat.
Fase 0: A FundaÃ§Ã£o (O Monorepo)
Objetivo: Estabelecer o ambiente de desenvolvimento onde Rust, React e React Native
convivem sem conflitos.
1.â€‹ Estrutura do Workspace:
â—‹â€‹ Inicializar Git.
â—‹â€‹ Configurar pnpm workspaces (como definido no package.json anterior).
â—‹â€‹ Configurar ESLint e Prettier na raiz para forÃ§ar padrÃ£o de cÃ³digo em todo o
projeto.
2.â€‹ Shared Packages:
â—‹â€‹ Criar o pacote packages/shared-types.
â—‹â€‹ Definir as Interfaces InboxItem, Note, AIRequest iniciais.
â—‹â€‹ Por que: Isso impede que o Frontend espere um campo title e o Backend
envie header.
DefiniÃ§Ã£o de Pronto (DoD):
â—â€‹ pnpm install roda sem erros.
â—â€‹ Ã‰ possÃ­vel importar uma interface de shared-types dentro do App Desktop e do
App Mobile.

Fase 1: O NÃºcleo Local (Desktop V0.1)
Objetivo: Criar um app Desktop que escreve arquivos Markdown e roda comandos Rust.
Sem IA, sem Mobile, sem Sync. Apenas IO.
Frontend (React/Tauri):

â—â€‹ Criar UI bÃ¡sica: Uma sidebar (lista de arquivos) e um editor de texto (Textarea
simples ou editor bÃ¡sico como react-markdown).
â—â€‹ Configurar Zustand para gerenciar o estado da nota atual.
Backend (Rust):
â—â€‹ Implementar vault_manager:
â—‹â€‹ fn list_files(path): Varre diretÃ³rio recursivamente.
â—‹â€‹ fn save_file(path, content): Escreve atomicamente no disco.
â—‹â€‹ fn read_file(path): LÃª conteÃºdo.
â—â€‹ Configurar o Tauri Command para expor essas funÃ§Ãµes ao Frontend.
DefiniÃ§Ã£o de Pronto (DoD):
â—â€‹
â—â€‹
â—â€‹
â—â€‹

VocÃª abre o app Desktop.
Escreve "OlÃ¡ Mundo".
Clica em Salvar.
Um arquivo Ola Mundo.md aparece na pasta real do seu computador.

Fase 2: A ConexÃ£o (O Relay System)
Objetivo: Permitir que dados saiam do celular e cheguem ao Desktop via Supabase.
ImplementaÃ§Ã£o do fluxo "Offline-First".
Infraestrutura (Supabase):
â—â€‹ Criar projeto Supabase.
â—â€‹ Criar tabela inbox_queue:
â—‹â€‹ id (uuid), user_id, content_text, audio_url, status ('pending',
'processed'), created_at.
â—â€‹ Configurar Storage Bucket para arquivos de Ã¡udio (audio-inbox).
â—â€‹ Configurar RLS (Row Level Security) para seguranÃ§a.
Mobile (React Native/Expo):
â—â€‹ UI: BotÃ£o grande de gravar (mic) e campo de texto.
â—â€‹ LÃ³gica:
â—‹â€‹ Gravar Ã¡udio localmente.
â—‹â€‹ Ao parar, salvar no WatermelonDB (banco local do celular) com status
unsynced.
â—‹â€‹ Processo de Background: Tentar fazer upload para Supabase. Se falhar,
tentar novamente quando houver rede.
Backend (Rust - Desktop):
â—â€‹ Implementar sync_service (MÃ³dulo CrÃ­tico):

â—‹â€‹ Criar um loop (thread separada usando tokio::spawn) que roda a cada X
segundos.
â—‹â€‹ Fazer query no Supabase: SELECT * FROM inbox_queue WHERE
status = 'pending'.
â—‹â€‹ Se encontrar itens: Baixar conteÃºdo -> Salvar em pasta local /_inbox ->
Marcar no Supabase como processed.
DefiniÃ§Ã£o de Pronto (DoD):
â—â€‹ Com o Desktop fechado, vocÃª digita uma nota no Celular.
â—â€‹ Abre o Desktop.
â—â€‹ O Desktop detecta o novo item e cria um arquivo na pasta /_inbox.

Fase 3: A InteligÃªncia (IA & Pipeline)
Objetivo: Transformar o lixo que chega no /_inbox em notas estruturadas. IntegraÃ§Ã£o
com APIs.
Backend (Rust - AI Orchestrator):
â—â€‹ IntegraÃ§Ã£o API: Configurar cliente HTTP (reqwest) para OpenAI ou Groq.
â—â€‹ Pipeline de Ãudio:
â—‹â€‹ Detectar arquivo .wav ou .m4a na /_inbox.
â—‹â€‹ Enviar para API Whisper.
â—‹â€‹ Receber texto transcrito.
â—â€‹ Pipeline de Texto (LLM):
â—‹â€‹ Criar o System Prompt mestre (ex: "VocÃª Ã© um organizador PKM...").
â—‹â€‹ Enviar transcriÃ§Ã£o + Contexto.
â—‹â€‹ Receber JSON estruturado (conforme definido em types.ts).
Frontend (Desktop - UI de Triagem):
â—â€‹ Criar a aba "Inbox/Rascunhos".
â—â€‹ Mostrar comparaÃ§Ã£o: "Texto Original" vs "SugestÃ£o da IA".
â—â€‹ BotÃµes de AÃ§Ã£o: "Aprovar" (Move para pasta final), "Editar", "Rejeitar".
DefiniÃ§Ã£o de Pronto (DoD):
â—â€‹ VocÃª grava um Ã¡udio no celular: "Lembrar de comprar raÃ§Ã£o pro cachorro amanhÃ£ e
ver a nota do projeto Alpha".
â—â€‹ No Desktop, aparece uma sugestÃ£o de Nota:
â—‹â€‹ TÃ­tulo: "Comprar RaÃ§Ã£o & Projeto Alpha"
â—‹â€‹ Tags: #compras, #trabalho
â—‹â€‹ Task sugerida: "Comprar raÃ§Ã£o" (Data: AmanhÃ£).

Fase 4: VisualizaÃ§Ã£o e Agenda (O Diferencial)
Objetivo: Implementar o Grafo de Conhecimento e o sistema de Agenda.
O Grafo (Rust + React):
â—â€‹ Rust (graph_engine):
â—‹â€‹ Varre todos os .md.
â—‹â€‹ Regex para encontrar [[WikiLinks]].
â—‹â€‹ Monta lista de NÃ³s e Arestas.
â—‹â€‹ OtimizaÃ§Ã£o: Cachear o resultado e sÃ³ atualizar quando arquivos mudarem.
â—â€‹ React:
â—‹â€‹ Instalar react-force-graph-3d ou 2d.
â—‹â€‹ Receber dados do Rust e renderizar.
â—‹â€‹ Implementar clique no nÃ³ -> abre a nota.
A Agenda:
â—â€‹ Ler os arquivos JSON/Markdown que a IA marcou como EVENT ou TASK.
â—â€‹ Exibir em uma visualizaÃ§Ã£o de CalendÃ¡rio (biblioteca react-big-calendar ou
similar).
DefiniÃ§Ã£o de Pronto (DoD):
â—â€‹ Ver um mapa de bolinhas conectadas representando suas notas.
â—â€‹ Ver os compromissos extraÃ­dos da IA numa grade de calendÃ¡rio.

Fase 5: Polimento e Open Source
Objetivo: Preparar para distribuiÃ§Ã£o.
1.â€‹ ConfiguraÃ§Ãµes Locais:
â—‹â€‹ UI para o usuÃ¡rio inserir suas prÃ³prias API Keys (OpenAI, Supabase, Groq).
Crucial para Open Source.
2.â€‹ Instaladores:
â—‹â€‹ Configurar GitHub Actions para compilar binÃ¡rios .exe (Windows), .dmg
(Mac) e .deb (Linux) via Tauri Action.
3.â€‹ DocumentaÃ§Ã£o:
â—‹â€‹ Escrever README detalhado ensinando a fazer "Self-Host" do Supabase ou
usar o Free Tier.

6. Arquitetura da InformaÃ§Ã£o e UI/UX
Esta Ã© a Arquitetura de InformaÃ§Ã£o e Design de ExperiÃªncia (UI/UX) do Secretariat.

Este documento traduz a complexidade tÃ©cnica do backend (Rust/IA) em uma interface
humana, intuitiva e focada em fluxo ("flow"). O objetivo Ã© reduzir o atrito cognitivo: o usuÃ¡rio
nÃ£o deve "operar" o software, mas sim "pensar" atravÃ©s dele.

1. Filosofia de Design: "Calm & Active"
Diferente de ferramentas de PKM passivas (Obsidian, Notion) que sÃ£o "telas em branco", o
Secretariat Ã© Ativo.
â—â€‹ PrincÃ­pio 1: Captura Sem Atrito (Zero Friction Capture). O celular deve abrir e
gravar em menos de 2 segundos.
â—â€‹ PrincÃ­pio 2: A IA Ã© uma SugestÃ£o, nÃ£o uma Ordem. A UI deve sempre deixar
claro o que foi gerado pela mÃ¡quina e permitir reversÃ£o fÃ¡cil. O usuÃ¡rio mantÃ©m a
soberania dos dados.
â—â€‹ PrincÃ­pio 3: TransparÃªncia de Estado. Como Ã© um sistema offline-first com sync, a
UI deve comunicar sutilmente o estado da sincronizaÃ§Ã£o (conectado, syncando,
offline).
O Secretariat nÃ£o Ã© uma ferramenta.â€‹
Ã‰ um organismo cognitivo auxiliar.
Ele nasce para ser a extensÃ£o sensÃ­vel, contÃ­nua e ativa do pensamento humano â€”
principalmente daquele que cria, pesquisa, conecta e intui.
Enquanto outras ferramentas pedem ao usuÃ¡rio que â€œorganizeâ€, â€œclassifiqueâ€, â€œmantenhaâ€ â€”â€‹
o Secretariat faz isso por ele, silenciosamente, mas com presenÃ§a estÃ©tica e emocional.

âœ¦ Conceito central
â€œSeu pensamento merece uma casa viva.â€
O aplicativo nÃ£o Ã© neutro.â€‹
Ã‰ presente, caloroso, estÃ¡vel, envolvente, como um cavalo de corrida:â€‹
poderoso, elegante, responsivo, confiÃ¡vel, feito para velocidade e resistÃªncia.

2. Arquetipo SimbÃ³lico â€“ O Cavalo
Secretariat
O nome evoca dois eixos:

2.1. O Cavalo â€“ ForÃ§a, Velocidade, Lealdade

O cavalo Secretariat Ã© um mito:
â—â€‹ velocidade absurda,â€‹
â—â€‹ constÃ¢ncia,â€‹
â—â€‹ desempenho que desafiou limites humanos.â€‹

Esses atributos definem o tom do app:
CaracterÃ­s
tica

TraduÃ§Ã£o para UX

Velocidade

tudo Ã© imediato, sem travas

ElegÃ¢ncia

animaÃ§Ãµes suaves, coerÃªncia tipogrÃ¡fica

Determina
Ã§Ã£o

feedbacks claros, sem ambiguidade

Lealdade

consistÃªncia, previsibilidade, seguranÃ§a de
dados

2.2. O SecretÃ¡rio â€“ Ordem, MemÃ³ria, ExecuÃ§Ã£o
Um secretÃ¡rio organiza, lembra, agenda e conecta informaÃ§Ãµes.
Mas este Ã© um secretÃ¡rio nÃ£o humano,â€‹
um hÃ­brido orgÃ¢nico-sintÃ©tico cuja funÃ§Ã£o Ã© amplificar sua capacidade cognitiva.

3. Personalidade do Produto
O Secretariat possui um ethos prÃ³prio:

3.1. Tom
â—â€‹ SÃ³brio,â€‹

â—â€‹ preciso,â€‹
â—â€‹ sereno,â€‹
â—â€‹ profissional,â€‹
â—â€‹ com autoridade silenciosa.â€‹

Nunca Ã© cÃ´mico, exagerado, infantil ou informal demais.

3.2. Postura
â—â€‹ Nunca compete com o usuÃ¡rio.â€‹
â—â€‹ Nunca tenta ser â€œamigoâ€.â€‹
â—â€‹ Age como um mentor discreto, um copiloto maduro.â€‹

3.3. Linguagem
Sempre clara, minimalista em palavras, sofisticada em estrutura:
â€œTranscriÃ§Ã£o processada. SugestÃ£o de nota disponÃ­vel.â€â€‹
â€œEvento criado. Revise quando desejar.â€â€‹
â€œEncontrei 4 relaÃ§Ãµes relevantes.â€

4. DESIGN BIBLE
EstÃ©tica: Tropical Concrete Noir
"Nas brechas do concreto, a mente floresce."

1. O Conceito Visual (Visual Concept)
O Secretariat nÃ£o Ã© uma folha de papel em branco; ele Ã© um muro descascado onde ideias
sÃ£o pichadas antes de serem esquecidas. A interface deve evocar a sensaÃ§Ã£o de operar
um terminal de computador antigo, encontrado nos fundos de um sebo no centro de uma
metrÃ³pole chuvosa. Ã‰ uma ferramenta para o "Intelectual do Subsolo": robusta, suja,
funcional e com uma aura de mistÃ©rio sagrado.
Pilares Visuais:
1.â€‹ Entropia Digital: Nada Ã© perfeitamente limpo. HÃ¡ ruÃ­do, grÃ£o e imperfeiÃ§Ã£o.

2.â€‹ Brutalismo Urbano: Estruturas pesadas, linhas duras, tipografia que grita como
manchetes ou sussurra como cÃ³digo.
3.â€‹ Gambiarra High-Tech: A tecnologia parece remendada, funcional, mas velha.
Cabos, terminais CRT, luz de sÃ³dio.
4.â€‹ Sacralidade Profana: A organizaÃ§Ã£o do conhecimento Ã© tratada como um ritual
religioso em meio ao caos.

2. Paleta CromÃ¡tica: "OxidaÃ§Ã£o Urbana"
A cor nÃ£o serve para "enfeitar", mas para iluminar a escuridÃ£o ou sinalizar perigo. A base Ã©
escura, nÃ£o por elegÃ¢ncia, mas por falta de luz.

2.1. SuperfÃ­cies (Backgrounds)
A tela nunca Ã© #000000 chapado. Ela tem textura e profundidade.
â—â€‹ Asfalto Molhado (Base Principal): #18181a (Um cinza quase preto, levemente
azulado/frio).
â—â€‹ Concreto Ãšmido (Cards/Paineis): #2b2b2d (Cinza chumbo com textura de ruÃ­do).
â—â€‹ Papel de Sebo (Ãrea de Texto): #dcd6c5 (Um bege acinzentado, "sujo", com baixa
opacidade para fundir com o fundo escuro, ou usado invertido como tinta).

2.2. IluminaÃ§Ã£o & Destaques (Accents)
Cores que cortam a neblina.
â—â€‹ Ã‚mbar SÃ³dio (Primary Action/Focus): #ffb042
â—‹â€‹ Uso: Cursor, botÃµes de gravaÃ§Ã£o, alertas crÃ­ticos. Representa a luz dos
postes de rua refletindo em poÃ§as de Ã³leo.
â—â€‹ Ferrugem Sangue (Alerts/Destructive): #8a3324
â—‹â€‹ Uso: Erros, deleÃ§Ã£o, nÃ³s de grafo desconectados. A cor de estruturas
metÃ¡licas corroÃ­das.
â—â€‹ Verde Limo (Success/AI/System): #4a5d45 (desbotado) ou #76ff03 (terminal CRT
brilhante - para IA).
â—‹â€‹ Uso: Mensagens do sistema, terminais de cÃ³digo, status "online".
â—â€‹ SÃ©pia FumaÃ§a (Secondary Text): #8c8578
â—‹â€‹ Uso: Metadados, datas, comentÃ¡rios. Cor de bituca de cigarro e poeira.

3. Tipografia: O Conflito Sagrado
A tipografia Ã© o choque entre a manchete do jornal sensacionalista, a bÃ­blia antiga e o
cÃ³digo de computador.

3.1. TÃ­tulos e Identidade (The Sacred/The Headlines)
â—â€‹ Fonte: Chomsky, Old London ou UnifrakturMaguntia (Blackletter/GÃ³tica).
â—â€‹ Uso: TÃ­tulo da aplicaÃ§Ã£o ("Secretariat"), cabeÃ§alhos de seÃ§Ãµes principais (ex:
"AGENDA", "ARQUIVO MORTO").
â—â€‹ Tratamento: Usado com parcimÃ´nia para criar peso visual e autoridade ancestral.

3.2. Interface e NavegaÃ§Ã£o (The Brutalist Infrastructure)

â—â€‹ Fonte: Archivo Black, Impact ou Helvetica Neue Condensed Bold.
â—â€‹ Uso: BotÃµes, abas, avisos de sistema.
â—â€‹ Tratamento: Caixa alta (ALL CAPS), espaÃ§amento apertado (tracking negativo).
Deve parecer sinalizaÃ§Ã£o de viaduto ou aviso de perigo.

3.3. Editor e Dados (The Intellectual Machine)
â—â€‹ Fonte: JetBrains Mono, Courier Prime ou VT323.
â—â€‹ Uso: Corpo das notas, input de chat, JSON, metadados.
â—â€‹ Tratamento: Monospaced. Deve parecer que foi batido em uma mÃ¡quina de escrever
elÃ©trica ou impresso em uma tela de fÃ³sforo verde.

4. Texturas e Efeitos de UI (Look & Feel)
Aqui reside a alma do "Tropical Concrete Noir". O CSS deve simular a deterioraÃ§Ã£o fÃ­sica.

4.1. GrÃ£o e RuÃ­do (ISO Noise)
â—â€‹ AplicaÃ§Ã£o Global: Uma camada (overlay) de ruÃ­do estÃ¡tico (noise) com 3% a 5% de
opacidade sobre toda a interface. Isso mata a "pureza" digital.
â—â€‹ Efeito: Unifica os elementos e dÃ¡ a sensaÃ§Ã£o de filme fotogrÃ¡fico de alta
sensibilidade usado Ã  noite.

4.2. IluminaÃ§Ã£o VolumÃ©trica (Glow & Haze)
â—â€‹ Soft Glow: Textos em cores "vivas" (como o Ã‚mbar ou Verde CRT) devem ter um
leve text-shadow para simular o sangramento de luz de monitores antigos ou
letreiros neon na neblina.
â—â€‹ Hard Shadows: Paineis e botÃµes nÃ£o tÃªm sombras difusas suaves (Google
Material). Eles tÃªm sombras duras e pretas (box-shadow: 4px 4px 0px #000), como a
luz dura de um refletor de seguranÃ§a.

4.3. Bordas e Divisores
â—â€‹ Estilo: Bordas de 1px sÃ³lidas e rÃ­spidas. Sem cantos arredondados (border-radius:
0px) ou cantos muito sutis (2px).
â—â€‹ Concreto Exposto: Linhas divisÃ³rias podem ser pontilhadas ou falhadas, simulando
mÃ¡ impressÃ£o.

5. Componentes de Interface (UI Kit)
5.1. O Editor (Main Stage)
â—â€‹ NÃ£o Ã© uma folha branca. Ã‰ um dossiÃª.
â—â€‹ Fundo escuro (#18181a). Texto em SÃ©pia Claro (#dcd6c5).
â—â€‹ Cursor: Um bloco sÃ³lido piscante (â–ˆ) em Ã‚mbar SÃ³dio.

5.2. O Grafo (The Neural Web)
â—â€‹ NÃ£o parece molÃ©culas coloridas. Parece um Radar de Controle de TrÃ¡fego AÃ©reo
ou um esquema elÃ©trico.
â—â€‹ Fundo: Preto profundo.

â—â€‹ NÃ³s: Cruzes (+), quadrados ou losangos pequenos.
â—â€‹ ConexÃµes: Linhas finas, verdes ou Ã¢mbar, com baixa opacidade.
â—â€‹ Efeito: Scanlines (linhas de varredura) passando suavemente sobre o grafo.

5.3. A Inbox/Triagem
â—â€‹ Layout de "Documento Confidencial".
â—â€‹ O texto original (esquerda) parece um fax ou xerox de mÃ¡ qualidade (contraste alto,
leve rotaÃ§Ã£o).
â—â€‹ A sugestÃ£o da IA (direita) aparece em fonte terminal verde, como se o computador
estivesse decifrando o caos.

5.4. Mobile (The Field Recorder)
â—â€‹ EstÃ©tica de Gravador JornalÃ­stico ou rÃ¡dio comunicador.
â—â€‹ BotÃ£o de Gravar: Um cÃ­rculo grande, vermelho-ferrugem, com textura tÃ¡til (anÃ©is
concÃªntricos).
â—â€‹ Feedback de Voz: NÃ£o uma onda suave, mas um grÃ¡fico de barras digitais (VU
Meter) que clippa no vermelho se falar alto.

6. Imagens e Iconografia
6.1. Iconografia
â—â€‹ Estilo: "Technical Drawing" ou Pixel Art de alta resoluÃ§Ã£o.
â—â€‹ Evitar Ã­cones preenchidos e arredondados. Usar linhas finas, Ã¢ngulos retos.
â—â€‹ Exemplos:
â—‹â€‹ Gravar: Um microfone de rÃ¡dio amador antigo.
â—‹â€‹ Agenda: Um calendÃ¡rio de parede rasgado.
â—‹â€‹ ConfiguraÃ§Ãµes: Uma engrenagem mecÃ¢nica suja de graxa.
â—‹â€‹ IA: Um olho estilizado (MaÃ§onaria/Illuminati) ou um chip exposto.

6.2. Tratamento de Imagens
â—â€‹ Qualquer imagem carregada no app (uploads do usuÃ¡rio) deve passar por um filtro
CSS automÃ¡tico:
â—‹â€‹ grayscale(80%) (quase preto e branco).
â—‹â€‹ contrast(120%) (alto contraste).
â—‹â€‹ sepia(20%) (tom envelhecido).

7. Sound Design & Haptics (Sensorial)
A experiÃªncia nÃ£o Ã© silenciosa. O "Noir" tem som.
â—â€‹ Sons de UI:
â—‹â€‹ Digitar: Barulho sutil de teclas mecÃ¢nicas ou relÃ©s estalando.
â—‹â€‹ NotificaÃ§Ã£o: Um som de "bip" de relÃ³gio digital antigo ou estÃ¡tica de rÃ¡dio.
â—‹â€‹ Sucesso: Um acorde grave e sintÃ©tico (estilo Vangelis/Blade Runner), nÃ£o um
"ding" alegre.
â—â€‹ Haptics (Mobile):

â—‹â€‹ VibraÃ§Ãµes secas e fortes. O celular deve parecer uma ferramenta pesada na
mÃ£o.

8. Exemplo PrÃ¡tico: A Tela de "Chat com IA"
CenÃ¡rio: O usuÃ¡rio pergunta algo Ã  IA.
Visual:
A janela de chat nÃ£o balÃµes arredondados (tipo WhatsApp).
Parece um Terminal de Comando (CMD).
â—â€‹
â—â€‹
â—â€‹
â—â€‹

UsuÃ¡rio: > [USER]: Resuma o projeto Alpha. (Texto em Ã‚mbar)
Processando: ... ACESSANDO ARQUIVOS ... (Texto piscando)
IA: > [SYSTEM]: AnÃ¡lise concluÃ­da. (Texto em Verde Limo)
O texto da resposta aparece caractere por caractere (efeito de digitaÃ§Ã£o
rÃ¡pida), como se estivesse sendo transmitido via conexÃ£o discada.

6. Movimento & MicrointeraÃ§Ãµes
O Secretariat deve parecer vivo, mas nunca chamativo.

PrincÃ­pios:
â—â€‹ Movimento orientado por funÃ§Ã£o, nÃ£o decoraÃ§Ã£o.â€‹
â—â€‹ TransiÃ§Ãµes de 120â€“180ms, suaves, contÃ­nuas.â€‹
â—â€‹ Feedback imediato em todas as aÃ§Ãµes (toque, clique, gravaÃ§Ã£o, salvar).â€‹

Exemplos:
â—â€‹ Ao aprovar uma nota da IA â†’ um pequeno â€œfade-inâ€ que simboliza integraÃ§Ã£o ao
cÃ©rebro.â€‹
â—â€‹ Ao gravar â†’ ondas pulsantes com amortecimento suave.â€‹
â—â€‹ Ao abrir o grafo â†’ nÃ³s emergem como sinapses se acendendo.â€‹

7. O Motivo Visual â€“ A Sinapse Equina
O Ã­cone do Secretariat Ã©:

A cabeÃ§a estilizada de um cavalo,
composta por linhas que lembram conexÃµes neurais.

7.1. InterpretaÃ§Ã£o simbÃ³lica
â—â€‹ A forma do cavalo â†’ forÃ§a, elegÃ¢ncia, velocidade.â€‹
â—â€‹ As linhas de sinapse â†’ memÃ³ria, grafo, inteligÃªncia.â€‹
â—â€‹ O olho â†’ atenÃ§Ã£o contÃ­nua.â€‹

7.2. Regras do logotipo
â—â€‹ Nunca usar com contornos finos demais.â€‹
â—â€‹ Manter proporÃ§Ãµes para evitar distorÃ§Ãµes simbÃ³licas.â€‹
â—â€‹ Evitar cores vibrantes fora da paleta.â€‹

3. Arquitetura de InformaÃ§Ã£o: Desktop
(The Command Center)
O Desktop Ã© dividido em trÃªs painÃ©is redimensionÃ¡veis (Layout Tripartite), padrÃ£o ouro
para apps de produtividade, mas com um twist para a IA.
Estrutura da Tela Principal:
[ Sidebar (NavegaÃ§Ã£o) ] | [ Main Stage (Editor/Grafo/Triagem) ] | [ Inspector (Contexto/IA) ]

A. Sidebar (Esquerda) - NavegaÃ§Ã£o
Focada em acesso rÃ¡pido, nÃ£o em Ã¡rvore de arquivos infinita.
1.â€‹ User Profile/Sync Status: Pequeno avatar com bolinha de status (Verde: Synced,
Amarelo: Syncing, Cinza: Offline).
2.â€‹ Omnibox (Busca Global + Comandos): Ctrl+K para buscar tudo.
3.â€‹ Inbox (Badge de NotificaÃ§Ã£o): Onde ficam as notas processadas esperando
aprovaÃ§Ã£o. Ex: Inbox (3).

ğŸ“…
ğŸ•¸ï¸
ğŸ“

4.â€‹ SessÃµes:
â—‹â€‹
Agenda (VisÃ£o CalendÃ¡rio).
â—‹â€‹
Neural Net (VisÃ£o de Grafos).
â—‹â€‹
Notes (Todas as notas).
5.â€‹ Smart Folders (Tags): Acesso rÃ¡pido a #tarefas, #ideias, #projetos.

B. Main Stage (Centro) - Onde o trabalho acontece
Este painel muda dependendo do modo:
1.â€‹ Modo Editor (PadrÃ£o):
â—‹â€‹ Editor Markdown WYSIWYG (O que vocÃª vÃª Ã© o que vocÃª tem).
â—‹â€‹ Suporte a blocos de cÃ³digo, LaTeX e imagens.
2.â€‹ Modo Triagem (Inbox Review) - Core Feature:
â—‹â€‹ Layout "Split View" (Comparativo).
â—‹â€‹ Esquerda: TranscriÃ§Ã£o original / Input Bruto.
â—‹â€‹ Direita: Nota Estruturada pela IA.
â—‹â€‹ AÃ§Ãµes flutuantes: "Aprovar (Enter)", "Editar", "Rejeitar (Descartar IA)".
3.â€‹ Modo Neural Net (Grafo):
â—‹â€‹ VisualizaÃ§Ã£o 3D/2D interativa.
â—‹â€‹ Filtros flutuantes: "Mostrar apenas notas conectadas a X".

C. Inspector (Direita) - O Copiloto
InformaÃ§Ãµes auxiliares que nÃ£o poluem o texto.
1.â€‹ Metadados: Data de criaÃ§Ã£o, tags.
2.â€‹ Backlinks: "O que linka para cÃ¡?".
3.â€‹ Chat com a Nota:
â—‹â€‹ Um input de chat na parte inferior.
â—‹â€‹ UsuÃ¡rio: "Resuma os pontos chave desta nota" ou "Quais tarefas estÃ£o
pendentes aqui?".
â—‹â€‹ Resposta da IA aparece como bolhas de chat efÃªmeras neste painel.

4. Arquitetura de InformaÃ§Ã£o: Mobile
(The Input Satellite)
O Mobile Ã© minimalista. NÃ£o Ã© para organizar, Ã© para capturar e consultar o prÃ³ximo passo.

NavegaÃ§Ã£o (Bottom Bar simplificada)
1.â€‹ Home (Feed): Ãšltimas capturas e "PrÃ³ximos Eventos".
2.â€‹ Captura (FAB - Floating Action Button): BotÃ£o central gigante.
3.â€‹ Agenda: CalendÃ¡rio somente leitura/ediÃ§Ã£o rÃ¡pida.

Telas Chave
1. Home Screen (O "Agora")
â—â€‹ Header: SaudaÃ§Ã£o contextual ("Bom dia, vocÃª tem 3 tarefas hoje").
â—â€‹ Agenda Card: Mostra o prÃ³ximo compromisso com contagem regressiva.
â—â€‹ Recent Captures: Lista cronolÃ³gica das Ãºltimas notas enviadas (status: "Enviado",
"Processando", "Sincronizado").
2. O Modo de Captura (Acionado pelo FAB)
â—â€‹ Abre instantaneamente (Cold start < 500ms).
â—â€‹ GravaÃ§Ã£o de Voz:
â—‹â€‹ Visualizador de onda sonora (Audio waveform) animado (feedback visual que
estÃ¡ ouvindo).
â—‹â€‹ BotÃ£o "Stop/Send".
â—‹â€‹ BotÃ£o "Cancelar".
â—â€‹ Texto RÃ¡pido: Teclado sobe automaticamente se o usuÃ¡rio nÃ£o falar em 2
segundos.
â—â€‹ Switch "Modo RÃ¡pido": Um toggle na tela. Se ativo = "NÃ£o usar IA, apenas salve o
Ã¡udio/texto cru".
3. Agenda (View)
â—â€‹ Lista vertical (Agenda View) rolÃ¡vel.
â—â€‹ Ao clicar num item, abre detalhes simples (Hora, Local, Nota vinculada).

5. Fluxos de UsuÃ¡rio (User Journeys)
Aqui detalhamos a UX dos processos crÃ­ticos.

Fluxo A: Captura de Voz atÃ© a EstruturaÃ§Ã£o (The Happy Path)
1.â€‹ Mobile: UsuÃ¡rio toca no FAB -> Fala "Agendar dentista amanhÃ£ Ã s 10 e lembrar de
levar o raio-x".
2.â€‹ Feedback Mobile: App mostra "Enviando..." -> "Salvo na Nuvem". UsuÃ¡rio guarda o
celular.
3.â€‹ Processamento (Invisible): Relay -> Desktop baixa -> IA processa.
4.â€‹ Desktop: NotificaÃ§Ã£o discreta no Ã­cone do app (ponto azul).
5.â€‹ Desktop Triagem:
â—‹â€‹ UsuÃ¡rio clica em "Inbox".
â—‹â€‹ VÃª um Card sugerindo:
â– â€‹ Evento: Dentista (AmanhÃ£, 10:00).
â– â€‹ Task: Levar Raio-X.
â– â€‹ Tag: #saude.
â—‹â€‹ UsuÃ¡rio pressiona Enter ("Aprovar").
6.â€‹ Resultado: O evento vai para a Agenda e a nota para o arquivo, sumindo da Inbox.

Fluxo B: Chat com Notas (Knowledge Retrieval)
1.â€‹ Desktop: UsuÃ¡rio abre uma nota antiga sobre "Projeto X".
2.â€‹ AÃ§Ã£o: UsuÃ¡rio nÃ£o lembra o que foi decidido sobre o orÃ§amento.
3.â€‹ InteraÃ§Ã£o: No painel direito (Inspector), digita: "Qual foi o budget definido?".
4.â€‹ Resposta: A IA lÃª o conteÃºdo da nota (e links conectados) e responde no painel: "O
budget foi de R$ 50k, definido na reuniÃ£o de 12/05".

6. ConsideraÃ§Ãµes de UX EspecÃ­ficas para
HÃ­brido (Offline/Online)
â—â€‹ Indicadores de ConfianÃ§a:
â—‹â€‹ No Mobile, se estiver offline, o Ã­cone de nuvem fica cortado. Ao gravar,
aparece a mensagem "Salvo no dispositivo. Enviaremos quando retomar
conexÃ£o". Isso gera confianÃ§a.
â—â€‹ Conflitos de EdiÃ§Ã£o:
â—‹â€‹ Se o usuÃ¡rio editar a agenda no Mobile e no Desktop ao mesmo tempo (raro,
mas possÃ­vel), o sistema adotarÃ¡ a estratÃ©gia "Last Write Wins" (Ãšltima
gravaÃ§Ã£o ganha) para simplificar, mas manterÃ¡ um log de conflito no
Desktop.

7. Wireframes Textuais (EspecificaÃ§Ã£o de
Componentes)
Para ajudar no desenvolvimento React/React Native:
Componente: InboxItemCard (Desktop)
Plaintext
+-------------------------------------------------------+
| [Icon: Mic/Text] 10:42 AM - via Mobile
|
+-------------------------------------------------------+
| ORIGINAL (Transcribed):
|
| "Ideia para o app, fazer o botÃ£o ser laranja"
|
|
|
| ------------------ (divider) ---------------------- |
|
|
| AI SUGGESTION:
|
| Title: SugestÃ£o de UI - Cor do BotÃ£o
|
| Tags: [#ux] [#design]
|
| Body: Sugere alterar a cor primÃ¡ria para laranja. |

+-------------------------------------------------------+
| [Reject]
[Edit]
[APPROVE (Ctrl+Enter)]
+-------------------------------------------------------+

|

Componente: VoiceRecorder (Mobile)
Plaintext
+-------------------------------------------------------+
|
|
|
[ 00:12 ]
|
|
|
|
||||||||||||||||||||||||| (Waveform animada) |
|
|
|
( BotÃ£o Stop Grande Vermelho )
|
|
| "Ouvindo..."
|
+-------------------------------------------------------+

|

